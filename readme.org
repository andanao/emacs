#+TITLE: Emacs Literate Configuration
#+STARTUP: overview
#+TAGS: external(e) core(c)
This configuration tangles out to multiple individual files using
~org-babel-tangle~ on save of this file.

 To create the init files:
#+begin_src shell
emacs --batch -l org readme.org -f org-babel-tangle
#+end_src

[[Windows]] specific configuration settings are saved to ~windows.el~ and loaded on
the appropriate machines

The following projects and configurations have provided a source of inspiration
for my setup:
- [[https://github.com/SystemCrafters/crafted-emacs][Crafted Emacs]]
- [[https://github.com/rougier][Nicolas Rougier]] particularly [[https://github.com/rougier/nano-emacs?tab=readme-ov-file][NANO]] though everything he touches is gold
- [[https://github.com/minad/org-modern][Org Modern]]
- Progfolio's [[https://github.com/progfolio/.emacs.d/tree/master][.emacs.d]]

* early-init
:PROPERTIES:
:header-args: emacs-lisp :tangle early-init.el :results none :noweb yes :comments link
:END:

Enable debug on error at startup to automatically get debugging with init.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(setq debug-on-error t)
(add-hook 'after-init-hook '(lambda () (setq debug-on-error nil)))
#+end_src

** Set directory variables

The EMACS ~~~ directory is not the same on windows as it is on Linux, I keep my git directory on
windows at ~c:/users/username/git~.  Windows behaviour can sometimes be strange, and to avoid
unecessary headaches I avoid manually setting the emacs home directory.

#+begin_src emacs-lisp
(if (eq system-type 'windows-nt)
    (setq git-directory (concat "c:/Users/" user-login-name "/git/"))
    (setq git-directory (expand-file-name "~/git/")))
#+end_src

I keep my org directory in the same place

#+begin_src emacs-lisp
(setq org-directory (concat git-directory "org/"))
#+end_src

my emacs config also lives in the same place on all my machines
#+begin_src emacs-lisp
(setq ads/config-file (concat git-directory "emacs/readme.org"))
#+end_src
** Set utf-8 encoding
Taken from Doom emacs setup, migtht be worth setting ~(set-locale-environment
"en_US.UTF-8")~ on linux systems
#+begin_src emacs-lisp
(set-language-environment "UTF-8")
#+end_src
** Garbage Collection
(lifted from [[https://github.com/progfolio/.emacs.d?tab=readme-ov-file#garbage-collection][progfolio's init]])

=gc-cons-threshold= (800 KB) and =gc-cons-percentage= (0.1) control when the Emacs garbage collector can kick in.
Temporarily turning these off during init should decrease startup time.
Resetting them afterward will ensure that normal operations don't suffer from a large GC periods.

The following is a table shows values from popular Emacs configurations.

| Distribution | gc-cons-threshold |
|--------------+-------------------|
| Default      |            800000 |
| Doom         |          16777216 |
| Spacemacs    |         100000000 |

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+end_src

#+begin_src emacs-lisp
(defun +reset-init-values ()
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq ;;file-name-handler-alist default-file-name-handler-alist
           gc-cons-percentage 0.1
           gc-cons-threshold 100000000)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(add-hook 'after-init-hook '+reset-init-values)
#+end_src

** UI Changes

Changes to the UI to inhibit unused elements be used should speed up start up times by a bit
#+begin_src emacs-lisp
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)

(scroll-bar-mode -1)                    ;; Disable the visible scrollbar
(tool-bar-mode -1)                      ;; Disablet the toolbar
(tooltip-mode -1)                       ;; Disable tooltips
(menu-bar-mode -1)                      ;; Disable the menu bar

(customize-set-variable 'indent-tabs-mode nil)
#+end_src

Remove server instruction clients, on closing an emacs frame when emacs server is running
#+begin_src emacs-lisp
(setq server-client-instructions nil)
#+end_src

Implicitly resizing the Emacs frame adds to init time. Fonts larger than the system default can cause frame resizing, which adds to startup time.
#+begin_src emacs-lisp
(setq frame-inhibit-implied-resize t)
#+end_src

Silence the bell
#+begin_src emacs-lisp
(setq ring-bell-function #'ignore
      inhibit-startup-screen t)
#+end_src


** Package Usage
On corporate machines I've been unable to get elpaca/straight working, for linux I plan to use the Nix [[https://github.com/nix-community/emacs-overlay][emacs-overlay]]

#+begin_src emacs-lisp
(setq package-archives
      '(("melpa" . "https://melpa.org/packages/")
        ("gnu"  . "https://elpa.gnu.org/packages/")
        ("nongnu" . "https://elpa.nongnu.org/nongnu/")))

(setq use-package-always-ensure t)
(when (string= system-type 'gnu/linux)
  (setq use-package-always-demand t))
#+end_src
** Backup files
Set these so emacs doesn't litter files everywhere.  At some point I might check
out [[https://github.com/emacscollective/no-littering][no-littering]] but this works for now
#+begin_src emacs-li
(setq backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
(setq projectile-known-projects-file (expand-file-name "tmp/projectile-bookmarks.eld" user-emacs-directory)
      lsp-session-file (expand-file-name "tmp/.lsp-session-v1" user-emacs-directory))
#+end_src

** Environment setup
Suggested by [[lsp-mode]]
#+begin_src emacs-lisp
(setenv "LSP_USE_PLISTS" "true")
#+end_src

** Provide Early init

#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

* Emacs Settings
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:

#+begin_src emacs-lisp
;(set-background-color "#000000") ;; don't blind me at startup
(setq
 cursor-in-non-selected-windows nil
 large-file-warning-threshold 100000000 ;; 100Mb
 help-window-select t)

(blink-cursor-mode 0)
(fset 'yes-or-no-p 'y-or-n-p)           ;; Replace yes/no prompts with y/n
(global-subword-mode 1)                 ;; Iterate through CamelCase words
(put 'downcase-region 'disabled nil)    ;; Enable downcase-region
(put 'upcase-region 'disabled nil)      ;; Enable upcase-region
(put 'narrow-to-region 'disabled nil)   ;; Enable narrow commands

(setq custom-file (concat user-emacs-directory "custom.el"))

(add-to-list 'display-buffer-alist
  (cons "*Async Shell Command*" (cons #'display-buffer-no-window nil)))

(when (file-exists-p custom-file)
  (load custom-file nil t))
#+end_src

#+begin_src emacs-lisp
(setq delete-trailing-lines nil)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+end_src

I want to have line numbers whenever I'm in programming modes
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook '(lambda () (display-line-numbers-mode 1)))
#+end_src
** auto tangle files
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:

Automatically tangle my configuration files on save.

#+begin_src emacs-lisp
(setq org-babel-auto-tangle-file-list
      (list ads/config-file))
#+end_src

#+begin_src emacs-lisp
(defun org-babel-auto-tangle-files ()
  ;; Automatically tangle files in ~org-babel-auto-tangle-file-list~ when one of them is saved
  (when (member buffer-file-name org-babel-auto-tangle-file-list)
    (org-babel-tangle-file buffer-file-name)))
#+end_src

Add hook to after save hook when on org mode
#+begin_src emacs-lisp
(add-hook 'org-mode-hook
  (lambda () (add-hook 'after-save-hook 'org-babel-auto-tangle-files)))
#+end_src

* Theme
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:
** fonts
#+begin_src emacs-lisp
(setq
 mono "FiraCode Nerd Font"
 sans "Cantarell"
 serif "EtBembo")

;; Set Font sizes
(defvar default-font-size 140)

;; Set default font
(set-face-attribute 'default nil
		    :font mono
		    :family mono
		    :height default-font-size)

(set-face-attribute 'fixed-pitch nil
		    :font mono
		    :family mono
		    :height default-font-size)

(set-face-attribute 'variable-pitch nil
		    :font serif
		    :family serif
		    :height 1.1
		    :weight 'regular)

(customize-set-variable 'line-spacing 0.25)
#+end_src

** frames

Set frame padding to have some breathing room, making the dividers invisible is done with ~ads/modus-tweaks~
# #+begin_src emacs-lisp
(modify-all-frames-parameters
   `((right-divider-width . 20)
     (internal-border-width . 20)))
#+end_src

** modus-themes
I used to maintain my own theme, but I wanted a change and modus themes are nice looking, I
particularly like the light ~modus-operandi~ theme.

#+begin_src emacs-lisp
(use-package modus-themes
  :demand t
  :ensure t
  :custom
  (modus-themes-mixed-fonts t)
  (modus-themes-bold-constructs t))

(setq modus-themes-to-toggle
      '(modus-operandi modus-vivendi))

(setq modus-themes-headings
  '((0 . (regular 1.75))
    (1 . (regular 1.25))
    (2 . (regular 1.20))
    (3 . (regular 1.15))
    (t . (regular 1.10))
    ))

;; all
(setq modus-themes-common-palette-overrides
  '((bg-prose-block-contents bg-main)
    (bg-prose-block-delimiter bg-main)
    (fg-heading-0 fg-main)
    (fg-heading-1 fg-main)
    (fg-heading-2 fg-main)
    (fg-heading-3 fg-main)
    (fg-heading-4 fg-main)
    (fg-heading-5 fg-main)
    (fg-heading-6 fg-main)
    (fg-heading-7 fg-main)
    (fg-heading-8 fg-main)
    (fringe bg-main)
    (bg-mode-line-active bg-dim)
    (bg-mode-line-inactive bg-main)))

;; dark theme
(setq modus-vivendi-palette-overrides
      '((cursor "#ff2060")
        (bg-main "#000000")))

;;light theme
(setq modus-operandi-palette-overrides
    '((cursor red-intense)))
;; (modus-themes-select (modus-themes-get-current-theme))
#+end_src

*** modus-tweaks

#+begin_src emacs-lisp :tangle no :noweb-ref modus-tweaks
(modus-themes-with-colors
    (custom-set-faces
     ;; Modus
     `(modus-themes-prose-code ((,c :foreground ,fg-alt)))
     `(modus-themes-prose-verbatim ((,c :foreground ,fg-main)))
     ;; org mode
     `(org-checkbox ((,c :foreground ,fg-main)))
     `(org-table ((,c :foreground ,fg-main)))
     `(org-document-info ((,c :foreground ,fg-main)))
     `(org-drawer ((,c :height 0.9)))
     `(org-property-value ((,c :height 0.9)))
     `(prose-done ((,c :foreground ,fg-dim)))
     `(org-done ((,c :foreground ,fg-dim)))
     `(org-headline-done ((,c :foreground ,fg-dim)))
     `(org-ellipsis ((,c :foreground ,bg-main)))
     `(org-modern-label ((,c :height 0.7 :inherit fixed-pitch)))
     `(org-scheduled ((,c :foreground ,fg-main)))
     `(org-scheduled-today ((,c :foreground ,fg-main)))
     `(org-agenda-calendar-event ((,c :foreground ,fg-main)))
     `(org-scheduled-previously ((,c :weight normal :foreground ,fg-main)))
     `(org-modern-date-active ((,c :inherit org-modern-label :background ,bg-blue-nuanced)))
     `(org-modern-time-active ((,c :inherit org-modern-label :background ,bg-blue-subtle)))
     `(org-modern-date-inactive ((,c :inherit org-modern-label :background ,bg-dim)))
     `(org-modern-time-inactive ((,c :inherit org-modern-label :background ,bg-inactive)))
     ;; markdown mode
     `(markdown-list-face ((,c :foreground ,fg-main)))
     `(markdown-inline-code-face ((,c :foreground ,fg-main)))
     `(markdown-code-face ((,c :background ,bg-dim )))
     `(markdown-language-keyword-face ((,c :background ,bg-dim )))
     ;; line numbers
     `(line-number ((,c :background ,bg-main :height 0.8)))
     `(line-number-current-line ((,c :inherit line-number :background ,bg-main)))
     ;; misc
     `(link ((,c :foreground ,fg-main :underline ,fg-main)))
     `(org-link ((,c :foreground ,fg-main :underline ,fg-main)))
     `(bookmark-face ((,c :foreground ,fg-dim :distant-foreground ,fg-dim)))
     ;; Make frame dividers invisible
     `(fringe ((,c :background ,bg-main :foreground ,bg-main)))
     `(window-divider ((,c :background ,bg-main :foreground ,bg-main)))
     `(window-divider-first-pixel ((,c :background ,bg-main :foreground ,bg-main)))
     `(window-divider-last-pixel ((,c :background ,bg-main :foreground ,bg-main)))
     ;; Add "padding" to the mode lines
     ;; `(mode-line ((,c :box (:line-width 3 :color ,bg-mode-line-active))))
     ;; `(mode-line-inactive ((,c :box (:line-width 3 :color ,bg-mode-line-inactive))))
     ))
#+end_src


#+begin_src emacs-lisp :noweb yes
(load-theme 'modus-vivendi t)
(add-hook
 'after-init-hook
 (lambda ()
   (defun ads/modus-tweaks ()
     "Apply custom tweaks to modus themes"
     <<modus-tweaks>>
     )
   (add-hook 'modus-themes-after-load-theme-hook 'ads/modus-tweaks)
   (ads/modus-tweaks)))
#+end_src
* General.el
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:

[[https://github.com/noctuid/general.el#about][general.el]] provides a more convenient method for binding keys in emacs. I use it to set all of my
key bindings

#+begin_src emacs-lisp :lexical t
(use-package general
  :demand t
  :ensure t
  :config
  (general-override-mode)
  (general-auto-unbind-keys))
#+end_src

#+begin_src emacs-lisp :lexical t
(general-define-key
 :keymaps 'override
 :states '(insert normal hybrid motion visual operator emacs)
 :prefix "SPC"
 :global-prefix "C-SPC")

(general-create-definer ads/leader-keys
  :keymaps 'override
  :states '(insert normal hybrid motion visual operator emacs)
  :wk-full-keys nil
  :prefix "SPC"
  :global-prefix "C-SPC")
#+end_src

#+begin_src emacs-lisp :lexical t
(defun ads/keyboard-quit-dwim ()
  "Do-What-I-Mean behaviour for a general `keyboard-quit'.

The generic `keyboard-quit' does not do the expected thing when
the minibuffer is open.  Whereas we want it to close the
minibuffer, even without explicitly focusing it.

The DWIM behaviour of this command is as follows:

- When the region is active, disable it.
- When a minibuffer is open, but not focused, close the minibuffer.
- When the Completions buffer is selected, close it.
- In every other case use the regular `keyboard-quit'."
  (interactive)
  (cond
   ((region-active-p)
    (keyboard-quit))
   ((derived-mode-p 'completion-list-mode)
    (delete-completion-window))
   ((> (minibuffer-depth) 0)
    (abort-recursive-edit))
   ((evil-emacs-state-p)
    (evil-normal-state))
   (t
    (keyboard-quit))))

(general-define-key
 :states '(normal hybrid motion visual operator emacs)
 '"C-g" 'ads/keyboard-quit-dwim)
#+end_src

#+begin_src emacs-lisp
(ads/leader-keys
  "r" 'replace-regexp
  "C-j" 'jump-to-register)
#+end_src

** eval ~e~

#+begin_src emacs-lisp
(ads/leader-keys
  "e" '(:ignore t :which-key "eval")
  "eb" 'eval-buffer
  "ed" 'eval-defun
  "ee" 'eval-expression
  "ep" 'pp-eval-last-sexp
  "es" 'eval-last-sexp
  )
#+end_src

** quit ~q~

#+begin_src emacs-lisp
(ads/leader-keys
  "q" '(:ignore t :which-key "quit")
  "qQ" 'save-buffers-kill-emacs
  "qE" 'kill-emacs
  )
#+end_src

** narrow ~n~

#+begin_src emacs-lisp
(ads/leader-keys
  "n" '(:ignore t :which-key "narrow")
  "nn" 'narrow-to-region
  "nd" 'narrow-to-defun
  "np" 'narrow-to-page
  "nw" 'widen
  )
#+end_src

** windows, buffers, frames ~j~
#+begin_src emacs-lisp
(ads/leader-keys
  "j" '(:ignore t :which-key "frames")

  "jQ" 'delete-frame
  "jN" 'tear-off-window
  "jR" 'set-frame-name
  "jr" 'select-frame-by-name

  "j=" 'balance-windows-area
  "j_" 'split-window-vertically

  "jh" 'evil-window-left
  "jj" 'evil-window-down
  "jk" 'evil-window-up
  "jl" 'evil-window-right

  "jH" 'evil-window-move-far-left
  "jJ" 'evil-window-move-very-bottom
  "jK" 'evil-window-move-very-top
  "jL" 'evil-window-move-far-right
  )
#+end_src
** kill and restore ~k~

#+begin_src emacs-lisp
(winner-mode)
(ads/leader-keys
   "k" '(:ignore t :wk "kill")
   "kj" 'kill-buffer-and-window
   "kk" 'kill-current-buffer
   "kl" 'delete-window
   "k," 'winner-undo
   "ki" 'winner-redo)
#+end_src

** config ~c~


#+begin_src emacs-lisp
(ads/leader-keys
  "c" '(:ignore t :which-key "config")
  "cc" '((lambda () (interactive) (find-file ads/config-file))
	 :which-key "open config")
  "cI" '((lambda () (interactive) (load-file user-init-file))
	 :which-key "load init"))
#+end_src

** Toggles ~t~

#+begin_src emacs-lisp
(ads/leader-keys
    "t" '(:ignore t :which-key "toggles")
    "tt" 'modus-themes-toggle    ; toggle theme
    "tl" 'toggle-truncate-lines  ; toggle lines
    "tb" 'display-battery-mode   ; toggle battery
    "td" 'toggle-debug-on-error
    "tc" 'display-time-mode      ; toggle clock
    )
#+end_src

*** Toggle frame decoration
#+begin_src emacs-lisp
(defun ads/toggle-frame-decorations ()
  "Toggle frame decorations (title bar and borders)"
  (interactive)
  (let* ((current-state (frame-parameter nil 'undecorated))
         (new-state (not current-state)))
    (set-frame-parameter nil 'undecorated new-state)
    (message "Frame decorations %s" (if new-state "hidden" "shown"))))
(ads/leader-keys "tw" 'ads/toggle-frame-decorations) ;; Toggle window
#+end_src

* Packages
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:

** all-the-icons

Icons are a font so remember to call ~(all-the-icons-install-fonts)~

#+begin_src emacs-lisp
(use-package all-the-icons
  :if (display-graphic-p))
#+end_src

** all-the-icons-ibuffer

#+begin_src emacs-lisp
(use-package all-the-icons-ibuffer
  :hook (ibuffer-mode . all-the-icons-ibuffer-mode))
#+end_src


** anki-editor
[[https://github.com/anki-editor/anki-editor][anki-editor]] for emacs. [[https://yiufung.net/post/anki-org/][These]] [[https://rgoswami.me/posts/anki-decks-orgmode/][blog posts]] showing quite sophisticated emacs and
anki workflows and inspired me to keep using anki instead of an emacs specific
srs tool.  If I do eventually go that rout I'll likely just abandon what's in
Anki or just make some sort of migration script.
#+begin_src emacs-lisp
(use-package anki-editor
  :vc (:url "https://github.com/anki-editor/anki-editor" :rev :newest)
  ;; I think I can get away with resetting with a hook in the capture template
  ;; :hook (org-capture-after-finalize . anki-editor-reset-cloze-number) ; Reset cloze-number after each capture.
  :config
  (setq anki-editor-create-decks t
        anki-editor-org-tags-as-anki-tags t
        ads/anki-file (concat org-directory "anki.org"))


  (defun anki-editor-cloze-region-auto-incr (&optional arg)
    "Cloze region without hint and increase card number."
    (interactive)
    (anki-editor-cloze-region my-anki-editor-cloze-number "")
    (setq my-anki-editor-cloze-number (1+ my-anki-editor-cloze-number))
    (forward-sexp))
  (defun anki-editor-cloze-region-dont-incr (&optional arg)
    "Cloze region without hint using the previous card number."
    (interactive)
    (anki-editor-cloze-region (1- my-anki-editor-cloze-number) "")
    (forward-sexp))
  (defun anki-editor-reset-cloze-number (&optional arg)
    "Reset cloze number to ARG or 1"
    (interactive)
    (setq my-anki-editor-cloze-number (or arg 1)))
  (anki-editor-reset-cloze-number)

  (add-hook 'find-file-hook
            '(lambda ()
               (when
                 (string-equal-ignore-case buffer-file-name ads/anki-file)
                 (anki-editor-mode))))
  )
#+end_src

#+begin_src emacs-lisp
(ads/leader-keys
  :major-modes '(org-mode)
  ;; :keymaps '(org-mode-map)
  "ok" '(:ignore t :wk "anKi")
  "okp" 'anki-editor-push-new-notes
  "okP" 'anki-editor-push-notes
  "okk" 'anki-editor-cloze-region-auto-incr
  "okj" 'anki-editor-cloze-dwim
  "okg" 'anki-editor-gui-browse
  "okG" 'anki-editor-gui-add-cards
  )
#+end_src
** async
#+begin_src emacs-lisp
(use-package async
  :config
  (async-bytecomp-package-mode 1))
#+end_src
** auctex LaTeX
Also install MiKTex to generate PDFs

#+begin_src emacs-lisp
(use-package tex
  :ensure auctex)
(setq-default TeX-master nil)
(setq TeX-auto-save t
      TeX-parse-self t
      reftex-plug-into-AUCTeX t
      LaTeX-electric-left-right-brace t
      TeX-PDF-mode t
      TeX-source-correlate-mode t
      TeX-source-correlate-start-server t
      )

;; (setq preview-latex-debug t)

;; some of these do apply to linux I just haven't tested it
(when (eq system-type 'windows-nt)
  (setq preview-gs-command "C:/Program Files/gs/gs10.04.0/bin/gswin64c.exe"
	preview-gs-options '("-q" "-dNOPAUSE" "-dDELAYSAFER" "-dBATCH")

	preview-image-type 'dvipng  ; Try dvipng first
	preview-dvipng-command "dvipng"

	preview-prefer-preview-pdf nil  ; Don't prefer PDF preview
	preview-transparent-border 1
	preview-auto-cache-preamble nil
	preview-pdf-color-adjust-method nil))
#+end_src

** auto-fill
#+begin_src emacs-lisp
(customize-set-variable 'fill-column 100)
(add-hook 'text-mode-hook 'auto-fill-mode)
#+end_src
** auto-revert

#+begin_src emacs-lisp
(use-package autorevert
  :custom
  (auto-revert-interval 0.1 "Instantaneously revert")
  :config
  (if (eq system-type 'windows-nt)
      (global-auto-revert-mode nil)
      (global-auto-revert-mode t)))
#+end_src
** bookmark+
[[https://www.emacswiki.org/emacs/BookmarkPlus][BookmarkPlus]] [[[https://github.com/emacsmirror/bookmark-plus][git]]] adds a lot of useful functionality to bookmarks, hosted on the EMACS wiki and not
on MELPA

#+begin_src emacs-lisp
(use-package bookmark+
  :vc (:url "https://github.com/emacsmirror/bookmark-plus"
       :branch "master"))
(customize-set-variable 'bookmark-default-file '"~/.emacs.d/bookmarks")
(customize-set-variable 'bmkp-last-bookmark-file '"~/.emacs.d/bookmarks")
(customize-set-variable 'bmkp-last-as-first-bookmark-file 'nil)
#+end_src

** cape
[[https://github.com/minad/cape][CAPE]] (Completion At Point Extensions)

#+begin_src emacs-lisp
(use-package cape
  :bind ("M-p" . cape-prefix-map)
  :init
  (add-hook 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'completion-at-point-functions #'cape-file)
  (add-hook 'completion-at-point-functions #'cape-elisp-block))
#+end_src
** consult

[[https://github.com/minad/consult][Consult]] has quickly become one of my favorite emacs packages, it makes moving around emacs feel like magic

#+begin_src emacs-lisp
(use-package consult
  :demand t
  :config
  (general-define-key
   :states '(normal hybrid motion visual operator emacs)
   '"M-y" 'consult-yank-pop
   '"C-s" 'consult-line))
(ads/leader-keys
  "C-SPC" 'consult-buffer
  "SPC" 'consult-buffer
  "C-;" 'consult-register-store
  "C-r" 'consult-ripgrep
  "b" 'consult-bookmark)
#+end_src

** copy (yank) as markdown
This is really waht I wanted but copy as markdown is still good

#+begin_src emacs-lisp
(defun ads/yank-region-as-markdown (start end)
    "Convert region from START to END to markdown and copy to kill ring.
  If the buffer is in org-mode, converts org syntax to markdown.
  Otherwise, copies the region as-is."
    (interactive "r")
    (let ((text (buffer-substring-no-properties start end))
          (markdown-text))
      (if (derived-mode-p 'org-mode)
          ;; Convert org to markdown
          (with-temp-buffer
            (insert text)
            (org-mode)
            (setq markdown-text (org-export-string-as text 'md t))
            (kill-new markdown-text)
            (message "Region yanked as markdown (%d chars)" (length markdown-text)))
        ;; Not in org-mode, just copy as-is
        (kill-new text)
        (message "Region yanked (%d chars)" (length text)))))
(ads/leader-keys "oy" 'ads/yank-region-as-markdown)
#+end_src

** corfu

#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :hook (after-init . global-corfu-mode)
  :bind (:map corfu-map ("<tab>" . corfu-complete))
  :custom
  (tab-always-indent 'complete)
  (corfu-preview-current nil)
  (corfu-min-width 20)
  (corfu-popupinfo-delay '(1.0 . 0.2))

  :config

  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'

  ;; Sort by input history (no need to modify `corfu-sort-function').
  (with-eval-after-load 'savehist
    (corfu-history-mode 1)
    (add-to-list 'savehist-additional-variables 'corfu-history)))
#+end_src

** Dired

#+begin_src emacs-lisp
(require 'dired)
(add-hook 'dired-mode-hook 'dired-hide-details-mode)
(setq dired-kill-when-opening-new-dired-buffer t
      delete-by-moving-to-trash t)
(general-define-key
 :states '(normal motion emacs)
 :keymaps 'dired-mode-map
 "h" 'dired-up-directory
 "l" 'dired-find-file)
#+end_src

** display-time-mode
#+begin_src emacs-lisp
(setq display-time-24hr-format t
      display-time-day-and-date nil
      display-time-default-load-average nil)
(display-time-mode)
#+end_src
** display-battery

#+begin_src emacs-lisp
(display-battery-mode)
#+end_src

** doom-modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :demand t
  :init (doom-modeline-mode 1)
  :custom
  (doom-modeline-height 24)
  (doom-modeline-hud t)
  (doom-modeline-icon t)
  (doom-modeline-buffer-encoding nil)
  (doom-modeline-percent-position nil)
  (doom-modeline-time-icon nil)
  :config
  (setq
   line-number-mode nil
   column-number-mode nil))
#+end_src

** dwim-shell-commands

Run shell commands asynchronously
#+begin_src emacs-lisp
(use-package dwim-shell-command)
#+end_src
** eglot
emacs batteries included LSP mode

#+begin_src emacs-lisp
(use-package eglot
  :hook
  (rust-ts-mode . eglot-ensure)
  (python-ts-mode . eglot-ensure)
  (c-ts-mode . eglot-ensure)
  (c++-ts-mode . eglot-ensure)
  :custom
  (eglot-autoshutdown t)
  (eglot-sync-connect nil) ; Don't block on connection
  (eglot-connect-timeout 120) ; Longer timeout for remote
  (eglot-send-changes-idle-time 0.5) ; Debounce time for sending changes
  ;; eglot-events-buffer-size 0
  )
#+end_src

** emojify
[[https://github.com/iqbalansari/emacs-emojify?tab=readme-ov-file][emojify]] improves emoji usage in EMACS

#+begin_src emacs-lisp
(use-package emojify
  ;; :hook (after-init . global-emojify-mode)
  :custom
  (use-default-font-for-symbols nil)
  (emojify-emoji-styles '(unicode))
  (emojify-display-style 'unicode)
  :config
  (if (eq system-type 'windows-nt)
      (print "emojis skipped on windows")
    (add-hook 'after-init-hook 'global-emojify-mode))

  (when (member "Segoe UI Emoji" (font-family-list))
    (set-fontset-font t 'symbol "Segoe UI Emoji" nil 'prepend)
    (set-fontset-font t 'emoji "Segoe UI Emoji" nil 'prepend))
  ;; (when (member "OpenMoji" (font-family-list))
  ;;   (set-fontset-font t 'symbol "OpenMoji" nil 'prepend)
  ;;   (set-fontset-font t 'emoji "OpenMoji" nil 'prepend))
  (ads/leader-keys
    "ie" 'emojify-insert-emoji))
#+end_src

** evil                                                            :core:
#+begin_src emacs-lisp
(use-package evil
  :demand t
  :preface (setq evil-want-keybinding nil)
  :custom
  (evil-want-integration t)
  (evil-want-keybinding  nil)
  (evil-want-C-u-scroll  nil)
  (evil-want-C-i-jump    nil)
  (evil-want-C-w-delete  nil)
  (evil-complete-all-buffers nil)
  :hook
  (after-init . evil-mode)
  (after-save . evil-normal-state)

  :config
  (general-define-key :states 'insert "C-g" 'evil-normal-state)
  (general-define-key "C-;" 'evil-switch-to-windows-last-buffer)

  ;; Use visual line motions even outside of visual-line mode buffers
  (evil-global-set-key 'motion "j" 'evil-next-visual-line)
  (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

  ;; set back normal mouse behaviour
  (define-key evil-motion-state-map [down-mouse-1] nil)
  ;; unbind q for macros
  (define-key evil-normal-state-map (kbd "q") 'nil)
  (define-key evil-normal-state-map (kbd "Q") 'nil)
  (evil-mode))

(general-define-key
  :states '(normal insert)
  "C-w C-h" 'evil-window-left
  "C-w C-j" 'evil-window-down
  "C-w C-k" 'evil-window-up
  "C-w C-l" 'evil-window-right)
#+end_src

** evil-anzu
Show match counts in modeline
#+begin_src emacs-lisp
(use-package evil-anzu
  :after (evil)
  :config
  (global-anzu-mode))
#+end_src

** evil-collection

A collection of evil bindings not fully set in the default package

#+begin_src emacs-lisp
(use-package evil-collection
  :after (evil)
  :custom
  (evil-collection-calendar-setup-want-org-bindings t)
  (evil-collection-setup-minibuffer t)
  :config
  (evil-collection-init))
#+end_src

** evil-surround
Surround a visula selection with input

#+begin_src emacs-lisp
(use-package evil-surround
  :ensure t
  :config
  (global-evil-surround-mode 1))
#+end_src

** git-link
Quickly create links to  files and commits
#+begin_src emacs-lisp
(use-package git-link
  :custom
  (git-link-use-single-line-number 'nil)
  :config
  (ads/leader-keys
    "gf" 'git-link
    "gF" 'git-link-dispatch))
#+end_src
** helpful

#+begin_src emacs-lisp
(use-package helpful
  :demand t
  )

(general-define-key
  :states '(normal insert)
  "C-h C-v" 'describe-variable
  "C-h C-f" 'describe-function
  "C-h C-b" 'describe-bindings
  "C-h C-c" 'describe-key-briefly
  "C-h C-k" 'describe-key
  "C-h C-e" 'view-echo-area-messages
  "C-h C-j" 'describe-face)
#+end_src
** insert-variable-value
Sometimes when I'm writing code I want to be able to directly insert the value
of a variable in to the buffer I am editing.  There's probably a way to do this
if I look through the manual closely but this works for now.

#+begin_src emacs-lisp
(defun insert-any-variable-value (var)
  "Insert the value of any variable VAR at point."
  (interactive
   (list (intern (completing-read
		  "Insert variable value: "
                  (let (vars)
                    (mapatoms (lambda (sym)
				(when (boundp sym)
				  (push (symbol-name sym) vars))))
                    vars)))))
  (insert (format "%S" (symbol-value var))))

(ads/leader-keys
  "iv" 'insert-any-variable-value)
#+end_src
** json
#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** kanata

#+begin_src emacs-lisp
(use-package kanata-kbd-mode
  :vc (:url "https://github.com/chmouel/kanata-kbd-mode/" :rev :newest)
  :mode ("\\.kbd\\'" . kanata-kbd-mode)
  )
#+end_src

** kdl

#+begin_src emacs-lisp
(use-package kdl-mode)
#+end_src

** magit

#+begin_src emacs-lisp
(use-package magit
  :config
  (transient-bind-q-to-quit)
  (setopt magit-format-file-function #'magit-format-file-nerd-icons)
  (defun ads/git-main ()
    "Checkout main"
    (interactive)
    (magit-checkout "main"))
  (defun ads/git-lazy ()
    (interactive)
    (save-buffer)
    (magit-file-stage)
    (magit-commit-create))
  (defun ads/git-amend ()
    (interactive)
    (save-buffer)
    (magit-file-stage)
    (magit-commit-amend "--no-edit"))

  (ads/leader-keys
   "g" '(:ignore t :wk "git")
   "C-g" 'magit-dispatch
   "gg" 'magit-status
   "gk" 'magit-commit
   "gl" 'ads/git-lazy
   "gm" 'ads/git-main
   "go" 'ads/git-amend
   "gp" 'magit-push
   "gP" 'vc-push
   "gs" 'magit-file-stage
   "gS" 'magit-stage
   "gu" 'magit-file-unstage
   "gU" 'magit-unstage))
#+end_src

** marginalia                                                      :core:

#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :demand t
  :hook (after-init . marginalia-mode)
  :config
  (marginalia-mode 1))
#+end_src
** markdown
#+begin_src emacs-lisp
(use-package markdown-mode
  :custom
  (markdown-fontify-code-blocks-natively)
  (markdown-fontify-code-block-default-mode)
  (markdown-list-item-bullets '("•"))
  (markdown-fontify-code-blocks-natively "t")
   :config
  (add-hook 'markdown-mode-hook 'variable-pitch-mode)
  (add-hook 'markdown-mode-hook 'markdown-display-inline-images)
  (add-hook 'markdown-view-mode-hook 'read-only-mode))

(ads/leader-keys
  :keymaps 'markdown-mode-map
  "oo" 'consult-outline
  "dm" 'markdown-view-mode)

(ads/leader-keys
  :keymaps 'markdown-view-mode-map
  "dm" 'markdown-mode)
#+end_src

** multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors
  :custom
  (mc/always-run-for-all t)
  :config
  (define-key mc/keymap (kbd "C-g") 'mc/keyboard-quit))
#+end_src

** nerd-icons

Remember run ~nerd-icons-install-fonts~ to get the font files.  Then
restart Emacs to see the effect.

   #+begin_src emacs-lisp
(use-package nerd-icons
  :ensure t)

(defun ads/nerd-icons-select ()
  "Select and return a nerd icon"
  (let* ((standard-output (current-buffer))
         (candidates (nerd-icons--read-candidates))
         (prompt    "Icon : ")
         (selection (completing-read prompt candidates nil t)))
        (cdr (assoc selection candidates))))

(ads/leader-keys
   "i" '(:ignore t :wk "insert")
   "ii" 'nerd-icons-insert
   "ic" 'insert-char)

(use-package nerd-icons-completion
  :ensure t
  :after marginalia
  :config
  (add-hook 'marginalia-mode-hook #'nerd-icons-completion-marginalia-setup))

(use-package nerd-icons-corfu
  :ensure t
  :after corfu
  :config
  (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

(use-package nerd-icons-dired
  :ensure t
  :hook
  (dired-mode . nerd-icons-dired-mode))
   #+end_src
** nix
#+begin_src emacs-lisp
(use-package nix-mode
  :config
  (global-nix-prettify-mode))
#+end_src

** no-littering

Stop leaving files everywhere
#+begin_src emacs-lisp
(setq backup-directory-alist `(("." . ,(expand-file-name "tmp/backups/" user-emacs-directory))))
(use-package no-littering)
#+end_src

** nov (epub)
Major mode for reading EPUB files in Emacs

#+begin_src emacs-lisp
(use-package nov
  :custom
  (nov-text-width 80)
  :config
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode)))
#+end_src

** orderless                                                       :core:

#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

** org

#+begin_src emacs-lisp
(use-package org
  :custom
  ;; (org-directory "~/org") ;; org directory set in early init
  (org-ellipsis " ·")
  (org-log-done 'time)
  (org-pretty-entities t)
  (org-return-follows-link t)
  (org-pretty-entities-include-sub-superscripts nil)
  (org-hidden-keywords '(title))
  (org-hide-emphasis-markers t)
  (org-image-actual-width 0.75)
  (org-startup-with-inline-images t)
  (org-fontify-whole-heading-line t)
  (org-fontify-done-headline t)
  (org-fontify-quote-and-verse-blocks t)
  (org-cycle-separator-lines 0)
  (org-id-link-to-org-use-id nil) ;; Use org roam linking
  (org-fast-tag-selection-single-key t)
  (org-blank-before-new-entry '((heading . 1) (plain-list-item . nil)))
  (org-todo-keywords '((sequence "TODO(t)" "|" "DONE(d!)")))
  (org-refile-use-outline-path 'title)
  (org-outline-path-complete-in-steps nil)
  (calendar-week-start-day 1)
  :hook
  (org-mode . variable-pitch-mode))
#+end_src

*** org-tags

#+begin_src emacs-lisp
(setq org-tag-alist
   '(("article" . ?r)
     ("book" . ?b)
     ("private" . ?P)
     ("thoughts" . ?t)
     ("public" . ?u)
     ;; Projects
     ("project" . ?p)   ; Generic/idea stage
     ("project_a" . ?a) ; Active
     ("project_h" . ?h) ; Hold
     ("project_c" . ?c) ; Complete
     ))
#+end_src
*** org-todo-keywords
Projects
#+begin_src emacs-lisp
(add-to-list 'org-todo-keywords
'(sequence "PLAN(p)" "NEXT(n)" "STOP(s!)" "HOLD(h!)"
		  "|" "DONE(d!)" "CANC(k!)") t)
#+end_src

Meetings
- ~SCHD~ Scheduled but nothing done
- ~PREP~ preparing notes, reading documents etc
- ~NOTE~ meeting started, taking actual notes and handling any open items
#+begin_src emacs-lisp
(add-to-list 'org-todo-keywords
'(sequence "SCHD(m)" "PREP(r!)" "NOTE(o!)"
		  "|" "DONE(d!)" "CANC(k!)" "SKIP(K!)") t)
#+end_src
*** org keybindings
:PROPERTIES:
:ID:       b675fb83-50bf-4177-9082-f9c039befbb9
:END:
Set custom org mode bindings and functions.

#+begin_src emacs-lisp
(general-define-key
 :states '(normal) :keymaps 'org-mode-map
 (kbd "<tab>") 'org-cycle
 (kbd "<backtab>") 'org-shifttab
 "C-j" 'org-next-visible-heading
 "C-k" 'org-previous-visible-heading)

(general-define-key
 :states  '(motion) :keymaps 'org-mode-map
 (kbd "RET") 'org-open-at-point)

(defun ads/consult-org-outline ()
  "Widen buffer, consult outline then narrow to subtree"
  (interactive)
  (widen)
  (consult-outline)
  (org-narrow-to-subtree)
  (org-fold-show-all))


(defun ads/org-scratch ()
  "Open ~/scratch.org"
  (interactive)
  (if (eq system-type 'windows-nt)
      (find-file (concat "c:/users/" user-login-name "/scratch.org"))
      (find-file "~/scratch.org")))
#+end_src


#+begin_src emacs-lisp
(ads/leader-keys
  "oM" 'org-mode
  "oS" 'org-save-all-org-buffers
  "C-c" 'org-clock-goto
  "C-s" 'ads/org-scratch
  "od" '((lambda () (interactive) (find-file org-directory)) :wk "org-directory"))

(ads/leader-keys
  :major-modes '(org-mode)
  "oo" 'ads/consult-org-outline
  "of" 'consult-outline
  "oh" 'consult-org-heading
  "o TAB" 'org-cycle-global
  "ti" 'org-redisplay-inline-images
  "tI" 'org-toggle-inline-images
  "ns" 'org-narrow-to-subtree
  "ne" 'org-narrow-to-element
  "nb" 'org-narrow-to-block
  )
#+end_src

*** org url links

#+begin_src emacs-lisp
(defun org-insert-link-from-kill ()
  "Insert an org-mode link using URL from kill ring and prompting for description.
First tries the most recent kill ring item, then searches kill ring history for a URL."
  (interactive)
  (let* ((first-item (current-kill 0))
         (url (if (string-match-p "^https?://" first-item)
                  first-item
                (cl-loop for i from 0 below (min kill-ring-max 20)
                         for item = (ignore-errors (current-kill i))
                         when (and item (string-match-p "^https?://" item))
                         return item)))
         (prompt-text (if url
                          (format "Link URL: %s\n"
                                  (if (> (length url) 100)
                                      (concat (substring url 0 100) "...")
                                    url))
                        (format "Not car of kill ring!\nLink URL: %s\n"
                                (if (> (length first-item) 100)
                                    (concat (substring first-item 0 100) "...")
                                  first-item))))
         (description (if url
                          (read-string prompt-text)
                        (progn
                          (message "No URL found in kill ring history")
                          nil))))
    (cond
     ((null description)
      (message "No URL available to create link"))
     ((string-empty-p description)
      (message "No description provided, link not inserted"))
     (t
      (insert (format "[[%s][%s]]" url description))))))

(ads/leader-keys "ol" 'org-insert-link-from-kill)
#+end_src

*** good morning review
Simpler than the weekly, more just to get my thoughts on paper and empty my mind
before starting the day

#+begin_src emacs-lisp :noweb-ref good-morning
"* Good Morning
,** What's on your mind right now?

,** What are you thinking about for work today?
"
#+end_src

#+begin_src emacs-lisp :noweb yes
(defun good-morning ()
  "Good morning funciton"
  (interactive)
  (org-roam-dailies-find-today)
   ; don't keep this here for long but for some reason calling daily doesnt make a node
  (org-id-get-create)
  (narrow-to-region (point-max) (point-max))
  (insert
<<good-morning>>
   )
  (goto-char (point-min))
  (org-clock-in)
  (delete-other-windows)
  (toggl-start-timer "start GoodMorning -p Admin"))
#+end_src

*** org weekly review
I do a weekly review, this will create the weekly review file in my current
daily and fill it in with some basic information.

#+begin_src emacs-lisp :noweb yes
(defun ads/weekly ()
  "start weekly review process"
  (interactive)
  (toggl-start-timer "start Weekly -p Admin")
  (browse-url "https://app.ynab.com")
  (org-roam-dailies-find-today)
  (org-roam-tag-add '("weekly"))
  (package-upgrade-all)
  (goto-char (point-max))
  (insert
<<ads/weekly>>
   ))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ads/weekly
"* Weekly Review

- [ ] [[https:calendar.google.com/calendar/u/0/r/week][Schedule Week]]
- [ ] [[https:app.ynab.com][YNAB]]
- [ ] Clear
  - [ ] [[id:a2a7d9b1-18b7-46f1-885c-68b9b87b29d5][Inbox]]
  - [ ] [[id:20128D1C-9D03-4AC6-94E2-4C479F7BAADA][Reading List]]
  - [ ] Downloads
  - [ ] [[https:gmail.com][gmail]]
- [ ] Clean Apartment
- [ ] Week agenda

,#+begin_src emacs-lisp
(org-agenda-list)
(org-agenda-week-view)
,#+end_src

,** Project Statuses

call ~ads/roam-active-projects-insert~

,** Goal Progress

Overview of montly goal progress

"
#+end_src

*** org monthly review
Template for my monthly reviews, I set it around the first of the month where I
plan out goals and theme tie in, at the end of the month I do complete the rest
of everything that is there.

#+begin_src emacs-lisp :noweb yes
(defun ads/monthly-new ()
  "New monthly review"
  (interactive)
  (find-file
   (concat org-directory (format-time-string "%Y_%m_monthly_review.org")))
  (toggl-start-timer "start Monthly -p Admin")
  (insert
   (format
<<ads/monthly>>
    (format-time-string "%B %Y")))
  (goto-char (point-min))
  (org-id-get-create))

(defun ads/monthly-current ()
  "Go to current monthly review"
  (interactive)
  (org-roam-node-visit
   (org-roam-node-from-title-or-alias
    (format-time-string "%B %Y Monthly"))))
#+end_src

#+begin_src emacs-lisp :tangle no :noweb-ref ads/monthly
"#+title:%s Monthly
#+filetags: :monthly:

,* Theme
#Beginning

,* Goals
#Beginning

,* Books Read
#End
(org-roam-ql-search
'(and (tags \"book\") (properties COMPLETED \"2025-06\")))

,* Time Tracked
#End

,* Thoughts had
#End

,* Projects

,** Active
#Beginning

,** Completed
#End

,* Reflection
#End

"
#+end_src
** org-agenda
#+begin_src emacs-lisp
(require 'org-agenda)
;; (evil-make-overriding-map org-agenda-mode-map)

(setq org-agenda-window-setup 'current-window
      org-agenda-span 'day
      org-agenda-block-separator ""
      org-agenda-restore-windows-after-quit t
      org-agenda-persistent-filter t
      org-agenda-scheduled-leaders '("   " "%2dd")
      org-agenda-skip-scheduled-if-done nil
      )

(setq org-agenda-prefix-format
      '((agenda . "  %-20 c%?-12t% s")
	(todo . "  %-20 c")
	(tags . "  %-20 c")
	(search . "  %-20 c")))

(setopt org-agenda-custom-commands
        '(("u" "Unscheduled TODOs"
           ((todo ""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))
                 (org-agenda-overriding-header "Unscheduled TODOs")))))
          ("t" "All tasks (no meetings)" ((tags-todo "-meeting")))))

(ads/leader-keys
  "oa" 'org-agenda-list ;; I use this more frequently
  "oA" 'org-agenda)
#+end_src

Largely taken from [[https://github.com/Somelauw/evil-org-mode/blob/master/evil-org-agenda.el#L42][evil-org-agenda]], but since there's only one mode applicable I
don't feel the need to use lots of the evil bindings
#+begin_src emacs-lisp
(general-define-key
 :keymaps 'org-agenda-mode-map
 "j" 'org-agenda-next-line
 "k" 'org-agenda-previous-line
 "M-j" 'org-agenda-drag-line-forward
 "M-k" 'org-agenda-drag-line-backward

 "h" 'org-agenda-earlier
 "l" 'org-agenda-later
 "H" 'org-agenda-do-date-earlier
 "L" 'org-agenda-do-date-later

 "S" 'org-agenda-schedule

 "m" 'org-agenda-bulk-toggle
 "M" 'org-agenda-bulk-unmark-all
 "R" 'org-agenda-bulk-mark-regexp
 "x" 'org-agenda-bulk-action

 "a" 'org-agenda-add-note
 "A" 'org-agenda-archive

 "u" 'org-agenda-undo
 ";" 'org-agenda-set-tags

 ;; go show
 "gr" 'org-agenda-redo
 "gR" 'org-agenda-redo-all
 "gc" 'org-agenda-goto-calendar
 "gt" 'org-agenda-show-tags
 "G" '(lambda () (interactive) (goto-line 3))
 "gg" '(lambda () (interactive)
         (forward-line 100)
         (forward-line -1))

 ;; delete
 "dd" 'org-agenda-kill
 "da" 'org-agenda-archive

 ;; filter
 "sc" 'org-agenda-filter-by-category
 "sr" 'org-agenda-filter-by-regexp
 "se" 'org-agenda-filter-by-effort
 "st" 'org-agenda-filter-by-tag
 "s^" 'org-agenda-filter-by-top-headline
 "ss" 'org-agenda-limit-interactively
 "S" 'org-agenda-filter-remove-all

 "C-w C-h" 'evil-window-left
 "C-w C-j" 'evil-window-down
 "C-w C-k" 'evil-window-up
 "C-w C-l" 'evil-window-right)
#+end_src
** org-appear

#+begin_src emacs-lisp
(use-package org-appear
  :custom
  (org-appear-autolinks t)
  (org-appear-autoentities t)
  (org-appear-autosubmarkers t)
  (org-appear-autokeywords nil)
  :hook
  ;; (org-mode . org-appear-mode)
  (evil-insert-state-exit . (lambda ()
	      (setq org-appear-delay 2)))
  (evil-insert-state-entry-hook .
	    (lambda ()
	      (setq org-appear-delay .3)))
  :config
  (if (eq system-type 'windows-nt)
      (print "org-appear skipped on windows")
      (add-hook 'org-mode-hook 'org-appear-mode))


  )
#+end_src

** org-babel

#+begin_src emacs-lisp :lexical t
(require 'org-tempo)
(require 'ob-tangle)

(customize-set-variable 'org-src-window-setup 'current-window)
(customize-set-variable 'org-src-preserve-indentation t)
(customize-set-variable 'org-edit-src-content-indentation 0)

(setq org-confirm-babel-evaluate nil)

(add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)

<<org-babel-config>>
#+end_src

*** config
:PROPERTIES:
:header-args: :noweb-ref org-babel-config
:END:

**** Structured Templates

#+begin_src emacs-lisp :lexical t
(dolist
    (template
     '(("el" . "src emacs-lisp")
       ("py" . "src python")
       ("sh" . "src shell")
       ("z" . "src zsh")
       ("nu" . "src nu")
       ("b" . "src bat")
       ("rs" . "src rust")
       ("html" . "src html")
       ("css" . "src css")
       ("cc" . "src C")
       ("cpp" . "src C++")
       ("cs" . "src C#")
       ("yaml" . "src yaml")
       ("toml" . "src toml")
       ("js" . "src javascript")
       ("json" . "src json")
       ("j" . "src json")
       ("ja" . "src java")
       ("sql" . "src sql")))
  (add-to-list 'org-structure-template-alist template))
#+end_src

#+RESULTS:

**** Languages

#+begin_src emacs-lisp
(with-eval-after-load 'org
     (org-babel-do-load-languages
         'org-babel-load-languages
         '((emacs-lisp . t)
           (shell . t)
           (python . t))))

    (setq org-confirm-babel-evaluate nil)

(setq org-babel-default-header-args:python
	     '((:results . "output")
	       ))
#+end_src
** org-capture
Capture all of my notes and tasks to an inbox where they are then reviewed
reviewed from there
#+begin_src emacs-lisp :noweb yes
(setq ads/inbox-file (concat org-directory "inbox.org")
      org-default-notes-file ads/inbox-file)

(defun ads/inbox ()
  "Open ads/inbox-file"
  (interactive)
  (find-file ads/inbox-file))

(defun ads/quick-note ()
  "take a note using the capture-note template"
  (interactive)
  (org-capture nil "n"))

(ads/leader-keys
  "oc" 'org-capture
  "oi" 'ads/inbox
  "C-a" 'ads/quick-note)
#+end_src

#+begin_src emacs-lisp
(setq org-capture-templates
      '(
<<capture-inbox>>
<<capture-task>>
<<capture-task-note>>
<<capture-task-inline>>
<<capture-note>>
<<capture-book>>
<<capture-anki-basic>>
<<capture-anki-cloze>>
<<capture-acronym>>
<<capture-quote>>
	))
#+end_src

*** capture-acronym
:PROPERTIES:
:ID:       b07758b9-e383-4299-a52f-359bb48c3a24
:END:

#+begin_src emacs-lisp :tangle no :noweb-ref capture-acronym
("x" "acronym" plain
 (file (lambda ()
         (concat
          org-directory
          (format-time-string "%Y%m%d%H%M%S--acronym.org" nil t))))
":PROPERTIES:
:ID: %(org-id-new)
:CREATED: %U
:ROAM_ALIASES: %^{Short}
:END:
,#+title: %^{Short}: %^{Definition}
,#+filetags: :acronym:

")
#+end_src
*** capture-anki-basic


#+begin_src emacs-lisp :tangle no :noweb-ref capture-anki-basic
("a" "anki basic" plain
(file ads/anki-file)
"* %^{TITLE}
:PROPERTIES:
:ANKI_NOTE_TYPE: Basic
:CREATED: %U
:END:
,** Front
%?
,** Back
,%x"
:jump-to-captured t)
#+end_src
*** capture-anki-cloze


#+begin_src emacs-lisp :tangle no :noweb-ref capture-anki-cloze
("z" "anki cloze" plain
(file ads/anki-file)
"* %^{TITLE}
:PROPERTIES:
:ANKI_NOTE_TYPE: Cloze
:CREATED: %U
:END:
%?
"
:jump-to-captured t)
#+end_src
*** capture-book
I initially planned to use ~org-roam-capture-templates~ but realized that I don't
capture books/articles/projects all that often and can just drop manually add
them with org capture instead of making the insertion of new nodes more of a pain

#+begin_src emacs-lisp :tangle no :noweb-ref capture-book
("b" "book" plain
 (file (lambda () (concat org-directory
                          (format-time-string "%Y%m%d%H%M%S-" nil t)
                          (string-replace " " "-" (read-string "filename "))
                          ".org")))
":PROPERTIES:
:ID: %(org-id-new)
:AUTHOR: %^{Author}
:MEDIUM: %^{MEDIUM ||audio|paper|electronic}
:COMPLETED: %^u
:END:
,#+title: %^{Title}
,#+filetags: :book:

%?"
:jump-to-captured t)
#+end_src

*** capture-inbox

#+begin_src emacs-lisp :tangle no :noweb-ref capture-inbox
("i" "inbox" plain
(file ads/inbox-file)
"* %^{}
:CREATED: %U
"
:immediate-finish t)
#+end_src
*** capture-note

#+begin_src emacs-lisp :tangle no :noweb-ref capture-note
("n" "note" plain
(file ads/inbox-file)
"* %^{HEADING}
:CREATED: %U

%?
")
#+end_src


*** capture-quote

#+begin_src emacs-lisp :tangle no :noweb-ref capture-quote
("q" "quote" plain
 (file (lambda ()
         (concat
          org-directory
          (format-time-string "%Y%m%d%H%M%S--quote.org" nil t))))
":PROPERTIES:
:ID: %(org-id-new)
:CREATED: %U
:SOURCE: %^{Source}
:END:
,#+title: %^{Description}
,#+filetags: :quote:

,#+begin_quote
%?
,#+end_quote

")
#+end_src

*** capture-task

#+begin_src emacs-lisp :tangle no :noweb-ref capture-task
("t" "todo - inbox" plain
(file ads/inbox-file)
"* TODO %^{TASK}
SCHEDULED: %t

"
:immediate-finish t)
#+end_src

*** capture-task-note

#+begin_src emacs-lisp :tangle no :noweb-ref capture-task-note
("r" "todo - inbox notes" plain
(file ads/inbox-file)
"* TODO %^{TASK}
SCHEDULED: %t

%?
")
#+end_src

*** capture-task-inline
#+NAME: capture-task-inline
#+begin_src emacs-lisp :tangle no
("c" "todo - inline" plain
(here)
"
,* TODO %^{TASK}
SCHEDULED: %t


"
:empty-lines 1
:immediate-finish t)
#+end_src

** org-cliplink

Take URL from clipboard and insert org mode link of title page

[[https://github.com/rexim/org-cliplink][GitHub - rexim/org-cliplink: Insert org-mode links from clipboard]]

#+begin_src emacs-lisp
(use-package org-cliplink)
(ads/leader-keys "oL" '(org-cliplink :wk "org-cliplink"))
#+end_src

** org-download
Better management of images in org mode for copying photos from internet and clipboard

#+begin_src emacs-lisp
(use-package org-download
  :vc (org-download
       :url "https://github.com/andanao/org-download"
       :main-file "org-download.el"
       :branch "master"
       :rev :newest)
  :hook
  (dired-mode . org-download-enable)
  (org-mode . org-download-enable)
  :custom
  (org-download-method 'attach)
  (org-download-screenshot-method 'imagemagick/convert)
  :config
  ;; firefox makes copied images into bmp so this helps
  (add-to-list 'image-file-name-extensions "bmp")
  (setq org-download-annotate-function '(lambda (link) ""))
  (ads/leader-keys
    :keymaps '(org-mode-map)
    "os" 'org-download-clipboard))
#+end_src
** org-habit
#+begin_src emacs-lisp
(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
#+end_src

** org meetings

Quickly jump and narrow to the first entry in a meeting series,

#+begin_src emacs-lisp
(require 'org-agenda)
(require 'org-element)

(defun ads/collect-meeting-todos ()
  "Collect all TODO entries tagged with :meeting: from org-agenda-files.
Returns a list of plists with :heading, :file, :point, and :scheduled properties."
  (let ((entries '()))
    (org-map-entries
     (lambda ()
       (let* ((heading (org-get-heading t t t t))
              (tags (org-get-tags))
              (todo-state (org-get-todo-state))
              (scheduled (org-get-scheduled-time (point)))
              (file (buffer-file-name))
              (pos (point)))
         (when (and todo-state
                    (member "meeting" tags)
                    (not (member todo-state org-done-keywords)))
           (push (list :heading heading
                       :file file
                       :point pos
                       :scheduled scheduled)
                 entries))))
     nil
     'agenda)
    (nreverse entries)))

(defun ads/get-unique-meetings (entries)
  "Extract unique meeting headings from ENTRIES.
Returns a sorted list of unique heading strings."
  (let ((headings (mapcar (lambda (entry) (plist-get entry :heading)) entries)))
    (sort (delete-dups headings) #'string<)))

(defun ads/jump-to-first-upcoming (meeting-heading entries)
  "Jump to the first upcoming instance of MEETING-HEADING in ENTRIES.
If scheduled times exist, picks the earliest future one.
Otherwise, picks the first occurrence."
  (let* ((matching-entries (seq-filter
                            (lambda (entry)
                              (string= (plist-get entry :heading) meeting-heading))
                            entries))
         (now (current-time))
         (future-entries (seq-filter
                          (lambda (entry)
                            (let ((sched (plist-get entry :scheduled)))
                              (and sched (time-less-p now sched))))
                          matching-entries))
         (sorted-entries (if future-entries
                             (sort future-entries
                                   (lambda (a b)
                                     (time-less-p (plist-get a :scheduled)
                                                  (plist-get b :scheduled))))
                           matching-entries))
         (target (car sorted-entries)))
    (if target
        (progn
          (find-file (plist-get target :file))
          (goto-char (plist-get target :point))
          (org-show-entry)
          (org-reveal)
          (recenter)
          (message "Jumped to: %s" meeting-heading))
      (message "No matching meeting found"))))


(defun ads/jump-to-meeting-todo ()
  "Select a meeting type and jump to its first upcoming TODO.
Collects all TODO items tagged with :meeting:, groups them by heading text,
prompts for selection, then jumps to the first upcoming instance."
  (interactive)
  (let* ((meeting-entries (ads/collect-meeting-todos))
         (unique-meetings (ads/get-unique-meetings meeting-entries))
         (selected-meeting (completing-read "Select meeting: " unique-meetings nil t)))
    (if selected-meeting
        (ads/jump-to-first-upcoming selected-meeting meeting-entries)
      (message "No meeting selected")))
  (org-narrow-to-subtree))

(ads/leader-keys "om" 'ads/jump-to-meeting-todo)
#+end_src
** org-modern
#+begin_src emacs-lisp
(use-package org-modern
  :after (org)
  :custom
  (org-modern-fold-stars
   '(("▸ " . "▾ ")
     ;; ("  ▸ " . "  ▾ ")
     ;; ("    ▸ " . "    ▾ ")
     ;; ("      ▸ " . "      ▾ ")
     ;; ("        ▸ " . "        ▾ ")
     ;; ("          ▸ " . "          ▾ ")
     ;; ("            ▸ " . "            ▾ ")
     ;; ("              ▸ " . "              ▾ ")
     ))
  (org-modern-checkbox
      '((?X . " ")
	(?- . " ")
	(?\s . " ")))
  (org-modern-table-vertical 2)
  (org-modern-table-horizontal 0.1)
  (org-modern-block-name nil)
  (org-modern-block-mode nil)
  (org-modern-list '((?- . "•")  (?+ . "◦")))
  :hook
  (org-mode . org-modern-mode)
  (org-agenda-finalize . org-modern-agenda))
#+end_src

*** org-modern-indent
small package to make the indentation work and visual fill column work in org modern


#+begin_src emacs-lisp
(use-package org-modern-indent
  :vc (:url "https://github.com/jdtsmith/org-modern-indent")
  :custom
  (org-startup-indented t)
  (org-indent-indentation-per-level 2)
  :config ; add late to hook
  (add-hook 'org-mode-hook #'org-modern-indent-mode 90))
#+end_src

** org-prettify-symbols

#+begin_src emacs-lisp
(defun ads/org-prettify-symbols ()
  "Set pretty entitie for org mode"
  (setq prettify-symbols-alist
        '(("lambda" . "λ")
          ("CLOSED:" . "󰃯")
          ("SCHEDULED:" . "󰃭")
          ("DEADLINE:" . "󰨱")
          ("PROPERTY:" . "󱌣")
          ("STARTUP:" . "开")
          ("RESULTS:" . "󰘍")
          (":results" . "󰘍")

          (":ID:" . "")
          (":AUTHOR:" . "")
          (":CATEGORY:" . "󰕲")
          (":SOURCE:" . "")
          (":COMPLETED:" . "󱓴")
          (":RECCOMENDER:" . "")
          (":MEDIUM:" . "󱚋")
          (":CREATED:" . "󰃳")
          (":LOGBOOK:" . "")
          (":PROPERTIES:" . "󱌣")
          (":END:" . "")

          (":ARCHIVE_NODE:" . "󱝜")
          (":ARCHIVE_TIME:" . "󱝐")
          (":ARCHIVE_FILE:" . "󱈎")
          (":ARCHIVE_CATEGORY:" . "󱝖")
          (":ARCHIVE_ITAGS:" . "󱝤")

          (":ROAM_ALIASES:" . "󰑕")

          ;; (":ANKI" . "📚")
          ;; ("_DECK:" . "")
          ;; ("_NOTE_TYPE:" . "󱕷")
          ;; ("_NOTE_ID:" . "")
          ;; ("_NOTE_HASH:" . "󱅿")

          ("+filetags:" . "")
          ("#+Author:" . "")
          ("#+options:" . "󰘵")
          (":tangle" . "󱓡")
          (":noweb" . "󰪎")
          (":noweb-ref" . "")
          (":mkdirp" . "")
          (":comments" . "󰆉")
          ("header-args:" . "󰉴")
          (":header-args" . "󰉴")

          ;; Blocks
          ("#+begin_quote" . "“")
          ("#+end_quote" . "”")
          ("#+begin_example" . "󰅴")
          ("#+end_example" . "")

          ;; Languages
          ("#+begin_src c" . "󰙱")
          ("#+begin_src cpp" . "󰙱")
          ("#+begin_src c++" . "󰙲")
          ("#+begin_src css" . "")
          ("#+begin_src dockerfile" . "")
          ("#+begin_src emacs-lisp" . "")
          ("#+begin_src html" . "")
          ("#+begin_src java" . "")
          ("#+begin_src javascript" . "")
          ("#+begin_src json" . "J")
          ("#+begin_src markdown" . "")
          ("#+begin_src python" . "")
          ("#+begin_src rust" . "󱘗")
          ("#+begin_src shell" . "")
          ("#+begin_src bash" . "")
          ("#+begin_src zsh" . "󰰶")
          ("#+begin_src nu" . "󰰒")
          ("#+begin_src sql" . "")
          ("#+begin_src toml" . "T")
          ("#+begin_src yaml" . "Y")

          ("#+end_src" . "»")))
  (prettify-symbols-mode 1))
(add-hook 'org-mode-hook 'ads/org-prettify-symbols)
#+end_src

** org-roam
[[https://github.com/org-roam/org-roam][Org-Roam]] is an org mode implementation of Roam Research's idea of a zettelkasten
like system with links between individual notes.  It is extremely powerful but
has a bit of a learning cuve to learn your way around and how best to work with
it.

Given that I use org-roam for personal and work at the same time on work
computers I have ~~/org/personal~ and ~~/org/work~

#+begin_src emacs-lisp
(use-package org-roam
  :demand t
  :init
  (setq org-roam-v2-ack t)
  :custom
  (org-roam-directory org-directory)
  (org-roam-completion-everywhere t)
  (org-roam-db-node-include-function
   (lambda ()
     (not (member "ATTACH" (org-get-tags))))) ;; ignore node if ATTACH is a tag

  (org-roam-capture-templates '(("d" "default" plain "%?" :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
":PROPERTIES:
:CREATED: %U
:END:
,#+title: ${title}
") :unnarrowed t)))

  :config
  (org-roam-db-autosync-mode)
  (org-roam-setup)
  (require 'org-roam-dailies)

  (ads/leader-keys
    "f" '(:ignore t :wk "roam")
    "d" 'org-roam-node-find
    "ff" 'org-roam-node-find
    "fD" '((lambda () (interactive)
	     (org-roam-db-sync)
	     (ads/org-agenda-files-update))
	   :wk "db sync & agenda")
    "fd" 'org-roam-dailies-map)

  (general-define-key :states '(insert visual) "C-f" 'org-roam-node-insert)

  (ads/leader-keys
    :major-modes '(org-mode)
    "C-f" 'org-roam-node-insert
    "fi" 'org-roam-node-insert
    "fa" 'org-roam-alias-add
    "fe" 'org-roam-extract-subtree
    "f;" 'org-roam-tag-add
    "f:" 'org-roam-tag-remove
    "fr" 'org-roam-ref-add
    "fR" 'org-roam-ref-remove
    "ft" 'org-roam-buffer-toggle))
#+end_src

I generate my org agenda files based off of an :agenda: tag in each org roam
file, in addition to an ~inbox.org~ file.  Credit to [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][d12frosted]] and
[[https://magnus.therning.org/2021-03-14-keeping-todo-items-in-org-roam.html][magnus.therning]] for the inspiration.

*** roam-agenda
:PROPERTIES:
:ID:       ebd0f06b-cfe3-4db3-a018-3f0307b303ed
:END:
#+begin_src emacs-lisp
(add-to-list 'org-tags-exclude-from-inheritance "agenda")
#+end_src

#+begin_src emacs-lisp
(defun ads/org-todo-p ()
  "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
  (org-element-map                          ; (2)
       (org-element-parse-buffer 'headline) ; (1)
       'headline
     (lambda (h)
       (eq (org-element-property :todo-type h)
           'todo))
     nil 'first-match))                     ; (3))
#+end_src

While most of roam agenda section is unchaged, a few org-roam functions have
been deprecated since writing and ~org-roam-tag-add~ has been added which
simplifies the task of adding a tag and ignoring files under daily
#+begin_src emacs-lisp
(defun ads/org-update-agenda-tag ()
  "Add :agenda: tag to the current org-roam buffer"
  (when (and (not (active-minibuffer-window))
             (not (string-match-p "/daily/" buffer-file-name))
             (org-roam-file-p buffer-file-name))
    (save-excursion
      (goto-char (point-min))
      (if (and (ads/org-todo-p)
               (not (member "project" (org-roam-node-tags (org-roam-node-at-point))))
               (not (member "project_h" (org-roam-node-tags (org-roam-node-at-point)))))
	  (org-roam-tag-add '("agenda"))
	  (org-roam-tag-remove '("agenda"))))))

(add-hook 'before-save-hook 'ads/org-update-agenda-tag)
#+end_src

#+begin_src emacs-lisp
(defun ads/org-roam-agenda-files ()
  "return a list of files containing the :agenda: tag"
  (seq-uniq
   (seq-map
    #'car
    (org-roam-db-query
     [:select [nodes:file]
      :from tags
      :left-join nodes
      :on (= tags:node-id nodes:id)
      :where (like tag (quote "%\"agenda\"%"))]))))

#+end_src

#+begin_src emacs-lisp
(defun ads/org-agenda-files-update (&optional arg)
  "Update org agenda files list"
  ;; Claim org-agenda-files here so custom.el doesn't mess with it
  (defvar org-agenda-files)
  (customize-set-variable 'org-agenda-files (ads/org-roam-agenda-files))
  (add-to-list 'org-agenda-files ads/inbox-file)
  (message "Agenda files updated from roam tags"))
(add-hook 'after-init-hook 'ads/org-agenda-files-update)

(advice-add 'org-agenda :before #'ads/org-agenda-files-update)
(advice-add 'org-todo-list :before #'ads/org-agenda-files-update)
#+end_src
*** roam-active-projects
For my [[weekly review]] I want a list of active projects.

#+begin_src emacs-lisp
(defun ads/roam-active-projects-insert ()
  "Insert roam links to active projects"
  (interactive)
  (dolist
    (node
     (org-roam-db-query
      [:select [nodes:id, nodes:title]
       :from tags
       :left-join nodes
       :on (= tags:node-id nodes:id)
       :where (like tag (quote "%\"project_a\"%"))]))
  (insert
     (concat "[[id:"
             (pop node) "]["
             (pop node) "]]
"))))
#+end_src


*** roam-categories

Categories in org agenda also get messed up, often I go back and fix them if I'm
going to be seeing it
#+begin_src emacs-lisp
(defun ads/org-node-name-to-category ()
  (interactive)
  (when (org-roam-file-p)
    (let* ((category-icon (ads/nerd-icons-select))
           (node-title (org-roam-node-title (org-roam-node-at-point)))
           (category-text (read-string
                           "Category: "
                           node-title ))
           (category (concat category-icon " " category-text)))
      (save-excursion
        (goto-char (point-min))
        (org-set-property "CATEGORY" category))
      (message category))))


(ads/leader-keys
  :major-modes '(org-mode)
  "fc" 'ads/org-node-name-to-category)
#+end_src
*** roam-capture-dailies
I want to prepend my daily captures

#+begin_src emacs-lisp
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry
         "* %?"
         :target (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>"))))
#+end_src
*** roam-daily-today
get today's daily file and if not make it
#+begin_src emacs-lisp
(setq org-roam-dailies-directory "daily/")
(defun ads/roam-daily-today ()
  "Return path of active daily"
  (concat
   org-roam-directory
   org-roam-dailies-directory
   (format-time-string "%Y-%m-%d.org")))

(defun ads/roam-refile-today ()
  "Refile current node to active daily"
  (interactive)
  (org-roam-refile
    (org-roam-node-from-title-or-alias
     (format-time-string "%Y-%m-%d"))))

(ads/leader-keys
  "fdr" 'ads/roam-refile-today)
#+end_src
*** roam-daily-archive
I want to archive small tasks to dailies but also link back to where the files
came from adding an ~:ARCHIVE_NODE:~ property.  Additionally move the attatched data if there
is any

#+begin_src emacs-lisp
(setq org-archive-location (concat (ads/roam-daily-today) "::")
      org-archive-save-context-info '(time file olpath category itags))

(run-at-time "00:01"
             86400
             '(lambda ()
                (setq org-archive-location
                      (concat (ads/roam-daily-today) "::"))))
#+end_src

#+begin_src emacs-lisp
(defun ads/org-archive ()
  "Archive file adding ARCHIVE_NODE property"
  (interactive)
  (let* ((node (org-roam-node-at-point))
	 (id (org-roam-node-id node))
	 (title (org-roam-node-title node))
	 (ref (concat "[[id:"id "][" title "]]")))
    (when (not (string= "Inbox" title))
     (org-set-property "ARCHIVE_NODE" ref)))
  (org-archive-subtree)
  (save-buffer))

(defun ads/org-archive-done ()
  "Change status to done and archive"
  (interactive)
  (org-todo 'done)
  (ads/org-archive))

(ads/leader-keys
  :major-modes '(org-mode)
  "ox" 'ads/org-archive
  "oX" 'ads/org-archive-done)
#+end_src


#+begin_src emacs-lisp
(defun org-archive-with-attatchments ()
  (when (org-attach-dir)
    (let*
       ((attach-dir (org-attach-dir))
        (destination (file-name-directory org-archive-location))
        (attach-dir-new
         (concat destination "data" (nth 1 (split-string attach-dir "data")))))
      (make-directory attach-dir-new t)
      (rename-file attach-dir attach-dir-new t))))
(advice-add 'org-archive-subtree :before 'org-archive-with-attatchments)
#+end_src
*** roam-insert-immediate
While writing and not wanting to create a rabbit hole for myself I want to make
a node immediately and not dive further into it.  Credit to [[https://www.youtube.com/watch?v=AyhPmypHDEw&lc=Ugw7bYrPOc6oy_UBmPZ4AaABAg][Umar Ahmad]]

#+begin_src emacs-lisp
(defun org-roam-node-insert-immediate (arg &rest args)
  (interactive "P")
  (let ((args (cons arg args))
        (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                  '(:immediate-finish t)))))
    (apply #'org-roam-node-insert args)))

(ads/leader-keys
  :major-modes '(org-mode)
  "fI" 'org-roam-node-insert-immediate)
#+end_src

*** roam-node-display
I want to be able to see where my files are and what tags they have when I
search for nodes and files

#+begin_src emacs-lisp
(cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name (org-roam-node-file node) org-roam-directory))))
    (error "")))

(setq org-roam-node-display-template
      (concat (propertize "${title:50}" 'face 'org-verbatim)
	      (propertize " ${tags:*}" 'face 'org-tag)
	      (propertize " ${type:1}" 'face 'org-roam-dim)
	      ))
#+end_src


*** roam-refile-tag-file-list
Not really roam but using org roam to create my refile targets.  Set my refile
targets to any file used by org-agenda or tagged :refile:, sometimes my roam
notes that are more todo-lists don't have any active tasks and thus aren't going
to be in my agenda


#+begin_src emacs-lisp
(defun ads/org-refile-files (&optional refile-arg)
  "Create a list of files containing the :refile: tag"
  (setopt ads/org-refile-files
   (seq-uniq
    (seq-map
     #'car
     (org-roam-db-query
      [:select [nodes:file]
       :from tags
       :left-join nodes
       :on (= tags:node-id nodes:id)
       :where (like tag (quote "%\"refile\"%"))])))))

(ads/org-refile-files)

(advice-add 'org-refile :before 'ads/org-refile-files)

(setopt org-refile-targets
        '((org-agenda-files :level . 0)
          (ads/org-refile-files :level . 0)))
#+end_src
*** roam-refile-note
On my work computers I keep 2 seperate org directories under ~~/git/org~ for work
and personal.  On my personal computers ~~/git/org/personal~ is just ~~/git/org~
which is all synced via git to my work computer.  When new files are created org
files are simply placed in the ~org-directory~ rather than deal with choosing
where they go while making a new note.  This makes things a bit of a pain if I
have to move a file somewhere else and there are attatchments, this function
will move the current note to work/personal

#+begin_src emacs-lisp
(defun org-move-note-with-attatchments (file destination)
  "Move note and it's attatchment directory to a new place"
  (let ((attach-dirs '()))
  (rename-file file (concat destination "/"))

  ;; make list of attach dirs
  (org-with-wide-buffer
   (goto-char (point-min))
   ;; At root
   (when (org-attach-dir)
     (push (org-attach-dir) attach-dirs))

   ;; At children
   (while (re-search-forward "^*" nil t)
     (when (org-attach-dir)
       (push (org-attach-dir) attach-dirs))))

  ;; move all files
  (dolist
      (attach-dir attach-dirs)
    (let
        ((new-dir (concat destination "/data" (nth 1 (split-string attach-dir "data")))))
      (make-directory new-dir t)
      (rename-file attach-dir new-dir t)))))


(defun ads/refile-move-work ()
  "move org file to work"
  (interactive)
  (org-move-note-with-attatchments buffer-file-name (concat org-directory "k2"))
  (kill-buffer)
  (find-file (car (directory-files org-directory t ".org"))))

(defun ads/refile-move-personal ()
  "move org file to work"
  (interactive)
  (org-move-note-with-attatchments buffer-file-name (concat org-directory "personal"))
  (kill-buffer)
  (find-file org-directory)
  (find-file (car (directory-files org-directory t ".org"))))
#+end_src

** org-roam-consult
really [[https://github.com/jgru/consult-org-roam][consult-org-roam]]

#+begin_src emacs-lisp
(use-package consult-org-roam
   :after org-roam
   :init
   (require 'consult-org-roam)
   ;; Activate the minor mode
   (consult-org-roam-mode 1)
   :custom
   ;; Use `ripgrep' for searching with `consult-org-roam-search'
   (consult-org-roam-grep-func #'consult-ripgrep)
   ;; Configure a custom narrow key for `consult-buffer'
   (consult-org-roam-buffer-narrow-key ?o)
   ;; Display org-roam buffers right after non-org-roam buffers
   ;; in consult-buffer (and not down at the bottom)
   (consult-org-roam-buffer-after-buffers nil)
   :config
   (consult-customize
    consult-org-roam-forward-links :preview-key "C-l"
    consult-org-roam-backlinks :preview-key "C-l"
    consult-org-roam-backlinks-recursive :preview-key "C-l"
    )
   (ads/leader-keys
    :major-modes '(org-mode)
    "ff" 'consult-org-roam-file-find
    "fs" 'consult-org-roam-search
    "fl" 'consult-org-roam-forward-links
    "fh" 'consult-org-roam-backlinks
    "fH" 'consult-org-roam-backlinks-recursive
    "fg" 'consult-org-roam-search ;; roam grep
    )
   )
#+end_src
** org-roam-ui
[[https://github.com/org-roam/org-roam-ui][Org-Roam-UI]] is a frontend for exploring and interacting with your org-roam notes.

#+begin_src emacs-lisp
(use-package org-roam-ui
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start t))
#+end_src

** org-roam-ql

Query language for [[org-roam]] it's very useful for performing db queries without
going through the sql queires.  Unfortunately wonderful org-ql (and it's roam
integration org-roam-ql-ql) doesn't play nice with files that don't have a 1st
level headline and only have a title, which is how all of my org roam files are
structured.

Getting books read in the last month:
#+begin_src emacs-lisp :tangle no
(org-roam-ql-search
'(and (tags "book") (properties COMPLETED "2025-06")))
#+end_src


#+begin_src emacs-lisp
(use-package org-roam-ql
  :after (org-roam)
  :bind
  ((:map org-roam-mode-map
         ("Q" . org-roam-ql-buffer-dispatch)))
  :config
  (ads/leader-keys
    "oq" 'org-roam-ql-search))
#+end_src

** org-tidy
[[https://github.com/jxq0/org-tidy][org-tidy]] will automatically hide property drawers

 #+begin_src emacs-lisp
(use-package org-tidy
  :ensure t
  :custom
  (org-tidy-properties-style 'invisible)
  (org-tidy-protect-overlay nil)
  :hook  (org-mode . org-tidy-mode)
  )
(ads/leader-keys
  :major-modes '(org-mode)
  "ot" 'org-tidy-untidy-buffer
  "oT" 'org-tidy-toggle
  "o C-t" 'org-tidy-mode)
#+end_src
** pdf-tools
[[https://github.com/vedang/pdf-tools?tab=readme-ov-file#installing-pdf-tools][pdf-tools]]
#+begin_src emacs-lisp
(use-package pdf-tools)
#+end_src
** projectile
[[https://github.com/bbatsov/projectile][Projectile]] is a popular emacs package used to manage projects

 #+begin_src emacs-lisp
(use-package projectile
  :custom
  (projectile-sort-order 'recently-active)
  :config
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
  (projectile-mode)
  (autoload 'projectile-project-root "projectile")
  (setq consult-project-function (lambda (_) (projectile-project-root)))

  (add-to-list 'projectile-globally-ignored-directories "*target")
  (add-to-list 'projectile-globally-ignored-directories "*venv"))

(ads/leader-keys
   "p" '(:ignore t :wk "projects")
   "pf" 'projectile-find-file-dwim
   "pp" 'consult-project-buffer
   "pP" 'projectile-switch-project
   "pj" 'projectile-next-project-buffer
   "pg" 'projectile-ripgrep
   "pk" 'projectile-previous-project-buffer)
#+end_src

** python
disabled for now because of weird org interactionsg
#+begin_src emacs-lisp :tangle no
(use-package python-mode
  :ensure t

  :custom
  (python-shell-interpreter "python3"))
#+end_src

** rainbow-delimiters

   #+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
   #+end_src

** rainbow-mode

   #+begin_src emacs-lisp
(use-package rainbow-mode
  :commands (rainbow-mode))
   #+end_src
** read-only-directories
Some directories I want to files to be opened in read-only mode because they are usually used for
reference

#+begin_src emacs-lisp
(defcustom read-only-directories '( )
  "list of directories or files that will be opened in read only mode")

(defun find-file-read-only-directories ()
"""
start buffer in read only mode if file in a child directory
 of in any of the directores defined in read-only-directories
"""
  (dolist (read-only-directory read-only-directories)
    (when (string-search read-only-directory buffer-file-name)
      (read-only-mode))))

(add-hook 'find-file-hook 'find-file-read-only-directories)
#+end_src
** recentf
#+begin_src emacs-lisp
(use-package recentf
  :custom
  (recentf-max-menu-items 1000 "Offer more recent files in menu")
  (recentf-max-saved-items 1000 "Save more recent files")
  :config
  (recentf-mode)
  )
#+end_src

** rg (ripgrep)

#+begin_src emacs-lisp
(use-package rg

  :config
  (rg-enable-default-bindings)
  (rg-enable-menu))
#+end_src

** rust
[[https://github.com/rust-lang/rust-mode][Rust-mode]] is a minimal package that provides Rust support and bindings supported
by the rust-lang team, alternatively [[https://github.com/emacs-rustic/rustic][Rustic]] offers a more fully featured experience.

#+begin_src emacs-lisp
(use-package rust-mode
  :init
  (setq rust-mode-treesitter-derive t)
  ;; :custom
  ;; (rust-format-on-save t)
  ;; :hook
  ;; (rust-mode-hook .(lambda () (setq indent-tabs-mode nil)))
  )
#+end_src

#+begin_src emacs-lisp
(ads/leader-keys
  :keymaps 'rust-mode-map
  "l" '(:ignore t :which-key "rust")
  "lc" 'rust-run-clippy
  "lc" 'rust-compile
  "lk" 'rust-check
  "lr" 'rust-run
  "lt" 'rust-test
  "ld" 'rust-dbg-wrap-or-unwrap
  "lm" 'rust-toggle-mutability
  )
#+end_src

** rustic
[[https://github.com/emacs-rustic/rustic?tab=readme-ov-file#eglot][Github - rustic]]

batteries included rust mode, builds upon rust-lang's rust-mode

#+begin_src emacs-lisp
(use-package rustic
  :after (rust-mode eglot)
  :custom
  (rustic-cargo-use-last-stored-arguments t)
  (rustic-lsp-client 'eglot))
#+end_src
** save-hist
#+begin_src emacs-lisp
(use-package savehist
  :config
  (savehist-mode 1))
#+end_src

** spacious-padding

#+begin_src emacs-lisp
(use-package spacious-padding
  :custom
  (spacious-padding-widths
      '(:internal-border-width 15
        :header-line-width 4
        :mode-line-width 6
        :tab-width 4
        :right-divider-width 30
        :scroll-bar-width 0
        :fringe-width 8))
  :config
  (spacious-padding-mode 1))
#+end_src
** sudo-edit
#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src

** symbol-overlay
Mark symbols [[https://github.com/wolray/symbol-overlay][wolray/symbol-overlay]]
#+begin_src emacs-lisp
(use-package symbol-overlay
  :config

  (define-key symbol-overlay-map (kbd "h") 'nil)
  (ads/leader-keys "s" symbol-overlay-map))
#+end_src
** telephone-line
#+begin_src emacs-lisp
(use-package telephone-line
  :custom
  (telephone-line-primary-left-separator 'telephone-line-cubed-right)
  (telephone-line-secondary-left-separator 'telephone-line-cubed-hollow-right)
  (telephone-line-primary-right-separator 'telephone-line-cubed-left)
  (telephone-line-secondary-right-separator 'telephone-line-cubed-hollow-left)
  :config
(setq telephone-line-height 24)
(setq telephone-line-evil-use-short-tag t)

)
#+end_src

** time-zones

Nice little package from xenodium for showing time zones

#+begin_src emacs-lisp
(use-package time-zones)
#+end_src

** toggl time tracking                                         :external:

I use [[https://track.toggl.com][toggl track]] to track my time, there isn't an emacs package for it but
there's a decently well made CLI for it.  This requires an external package but
it's fine for my use case.

To install the cli utility:
#+begin_src shell :tangle no
cargo install toggl
#+end_src

#+begin_src emacs-lisp
(setopt toggl-saved-timers-default
      '("stop"
        "continue"

        ;; Personal Productivity
        "start emacs -p Configuration -b"
        "start nix -p Configuration -b"
        "start mac -p Configuration -b"
        "start CAD -p Design -b"
        "start Anki -p 生词 -b"
        ;; "start Jobs -p Jobs -b"
        "start Moving -p Moving"
        ;; "start Interview -p Jobs -b"

        ;; General
        "start Admin -p Admin"
        "start Housekeeping -p Housekeeping"
        "start Walk -p Walks"
        "start Cooking -p Cooking"
        "start Chess -p Chess"
        "start Editing -p Photography"
        ))
(setopt toggl-saved-timers toggl-saved-timers-default)
#+end_src

#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
  (cons "toggl-start" (cons #'display-buffer-no-window nil)))

(defun toggl-start-timer (toggl-args)
  "Start timer passing toggl-args to cli"
  (async-shell-command
   (concat "toggl "toggl-args)
   "toggl-start")
  (message toggl-args))

(defun toggl-start-saved-timer ()
  "Start a timer from toggl-saved-timers"
  (interactive)
  (toggl-start-timer
   (string-replace
    "'"
    "\"" ;; \" <- bad parsing
    (completing-read "toggl " toggl-saved-timers))))

(ads/leader-keys
  "C-t" 'toggl-start-saved-timer)
#+end_src


** tramp
remote connections in emacs
#+begin_src emacs-lisp
(require 'tramp)
(setopt remote-file-name-access-timeout 300)
#+end_src

** treesit
#+begin_src emacs-lisp
(setq treesit-language-source-alist
      '((rust "https://github.com/tree-sitter/tree-sitter-rust"
              "v0.23.3" "src")))
#+end_src

** treesit-auto

Automatically install the treesitter language

#+begin_src emacs-lisp
(use-package treesit-auto
  :config
  (add-to-list 'treesit-auto-recipe-list
               (make-treesit-auto-recipe
                :lang 'rust
                :ts-mode 'rust-ts-mode
                :remap 'rust-mode
                :url "https://github.com/tree-sitter/tree-sitter-rust"
                :revision "v0.23.3"
                :ext "\\.rs\\'"))
  (setq major-mode-remap-alist
        (treesit-auto--build-major-mode-remap-alist))

   (setq treesit-auto-langs '(rust))
   (treesit-auto-add-to-auto-mode-alist '(rust))
   (global-treesit-auto-mode))
#+end_src

** treemacs

#+begin_src emacs-lisp
(use-package treemacs
  :config
  (ads/leader-keys
    "z" 'treemacs))
#+end_src

#+begin_src emacs-lisp
(use-package treemacs-evil
  :after treemacs evil)

(use-package treemacs-magit
  :after treemacs magit)

(use-package treemacs-projectile
  :after treemacs projectile)

(use-package treemacs-nerd-icons
  :after treemacs
  :config
  (treemacs-load-theme "nerd-icons"))
#+end_src


** ultra-scroll
Scroll Emacs like Lightining.

[[https://github.com/jdtsmith/ultra-scroll][ultra-scroll]] provides a better version of ~pixel-scroll-prescision-mode~ which
works much smoother on both Windows and Linux.

#+begin_src emacs-lisp
(use-package ultra-scroll
  :vc (ultra-scroll
       :url "https://github.com/jdtsmith/ultra-scroll"
       :main-file "ultra-scroll.el"
       :branch "main"
       :rev :newest)
  :init
  (setq scroll-conservatively 101
        scroll-margin 0)
  :config
  (when (not (eq system-type 'windows-nt))
    (ultra-scroll-mode 1)))
#+end_src

** vertico                                                         :core:

#+begin_src emacs-lisp
(use-package vertico
  :demand t
  :hook (after-init . vertico-mode)
  :config
  (vertico-mode 1)
  (general-define-key
   :states '(insert)
   :keymaps 'vertico-map
   "C-j" 'vertico-next
   "C-k" 'vertico-previous))
#+end_src

** visual-fill-column

#+begin_src emacs-lisp
(use-package visual-fill-column
  :custom
  (visual-fill-column-center-text t)
  (visual-fill-column-width 130)
  (global-visual-fill-column-mode t)
  :config
  (ads/leader-keys "tf" 'visual-fill-column-mode)
  )
#+end_src

** vterm                                                         :external:
Full fledged terminal, works great, now I never have to leave hotel california.

Requires external packages:
- ~libvterm~
- ~cmake~
- ~libtool-bin~

#+begin_src emacs-lisp
(use-package vterm
  :config
  (defun ads/vterm-ssh-connect (host)
    "Open vterm and connect to HOST via SSH"
    (interactive "sSSH host: ")
    (let ((vterm-buffer-name (format "vterm-%s" host)))
      (vterm)
      (vterm-send-string (format "ssh %s\n" host))))

  (ads/leader-keys
    "m" 'vterm))
#+end_src

*** vterm-toggle

#+begin_src emacs-lisp
(use-package vterm-toggle
  :after vterm
  :custom
  (vterm-toggle-scope 'project)
  :config
  (general-define-key "C-:" 'vterm-toggle)
  (ads/leader-keys
    ";" 'vterm-toggle))
#+end_src


** which-key

=which-key= is is included in EMACS 30

#+begin_src emacs-lisp
(use-package which-key
  :demand t
  :init
  (setq which-key-enable-extended-define-key t)
  :config
  (which-key-mode)
  :custom
  (which-key-side-window-location 'bottom)
  (which-key-sort-order 'which-key-key-order-alpha)
  (which-key-side-window-max-width 0.33)
  (which-key-idle-delay 0.5))
#+end_src

** yaml

#+begin_src emacs-lisp
(use-package yaml-mode
  :bind (:map yaml-mode-map
         ("RET" . newline-and-indent)))
#+end_src

** zoom
[[https://github.com/cyrus-and/zoom][zoom]] replacmeent  for golden ratio package
#+begin_src emacs-lisp
(use-package zoom
  :custom
  (zoom-ignored-major-modes '(dired-mode markdown-mode))
  (zoom-ignored-buffer-names '("readme.org" "init.el"))
  (zoom-ignored-buffer-name-regexps '("^*calc"))
  (zoom-ignore-predicates '((lambda () (> (count-lines (point-min) (point-max)) 20))))
  (zoom-size '(0.618 . 0.618))
  (zoom-mode nil)
  :config
  (ads/leader-keys
    "tz" 'zoom-mode))
#+end_src
* Computer specific configs
:PROPERTIES:
:header-args: emacs-lisp :tangle init.el :results none :noweb yes :comments link
:END:

Load windows only configuration
#+begin_src emacs-lisp
(when (eq system-type 'windows-nt)
  (load-file (concat user-emacs-directory "ms-windows.el")))

(when (eq system-type 'gnu/linux)
  (load-file (concat user-emacs-directory "linux.el")))

(when (eq system-type 'darwin)
  (load-file (concat user-emacs-directory "mac.el")))
#+end_src

Load when on appropriate system:
#+begin_src emacs-lisp
;; not reliable when called at startup
;; (when (string-equal-ignore-case system-name "k2-mac.local")
;;   (load-file (concat git-directory "konfig/work.el")))

(when (string-equal-ignore-case system-name "ganymede")
  (load-file (concat git-directory "windows-config/ganymede.el")))
#+end_src
* MS Windows
:PROPERTIES:
:header-args: emacs-lisp :tangle ms-windows.el :results none :noweb yes :comments link
:END:
Work forces me to use windows as much as I'd rather not.

To set emacs daemon to start on windows at login:
- win+r ~shell:startup~
- make shortcut to ~runemacs.exe~
- modify shortcut and add --daemon
Or open task scheduler and add a task to execute ~runemacs.exe --daemon flag~

#+begin_src emacs-lisp
(set-message-beep 'silent)
(setq win/.emacs.d (concat "C:\\Users\\" user-login-name "\\AppData\\Roaming\\.emacs.d\\"))
#+end_src

** copy files to ~.emacs.d~ on tangle
Windows doesn't allow symlinks unless you are an admin which is a pain.  In
order to keep the init files working properly copy the config files to
~C:\Users\username\AppData\Roaming\.emacs.d\~ after tangle

#+begin_src emacs-lisp
(defun win/copy-config-files-to-.emacs.d ()
    (when (string-equal-ignore-case buffer-file-name ads/config-file)
      (dolist (filename
	       '("early-init.el"
		 "init.el"
		 "ms-windows.el"))
	 (let ((target-filename (concat win/.emacs.d filename)))
	   (delete-file target-filename)
	   (copy-file filename target-filename)))
      (message "Copied config files to win/.emacs.d")))
(add-hook 'org-babel-tangle-finished-hook 'win/copy-config-files-to-.emacs.d)
#+end_src

#+begin_src emacs-lisp
(ads/leader-keys
  "cW" '((lambda () (interactive) (find-file win/.emacs.d))
	 :wk "Dired .emacs.d"))
#+end_src

** server mode
Windows seems to hate emacs daemon so I just start it here
#+begin_src emacs-lisp
(add-hook 'after-init-hook 'server-mode)
#+end_src

** ahk
I use AHK a lot to make the experience of using windows less painful
#+begin_src emacs-lisp
(use-package ahk-mode
  :ensure t
  :bind (:map ahk-mode-map
	      ("C-c C-c" . ahk-run-script)
	      ("C-c C-k" . nil)
	      )
  )
#+end_src
*** Window Spy
#+begin_src emacs-lisp
(defun ahk-launch-window-spy ()
  (interactive)
  (w32-shell-execute 1 "C:/Users/adanaos/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/AutoHotkey Window Spy.lnk"))
#+end_src
** align windows theme with emacs
#+begin_src emacs-lisp
;; win/theme
;;   0 - dark
;;   1 - light
(setq win/theme "0")

(add-to-list 'display-buffer-alist
  (cons "win/theme-toggle" (cons #'display-buffer-no-window nil)))
(defun win/theme-align-with-emacs ()
  ;;check if light or dark theme in emacs
  (if (string-search "vivendi"
		     (symbol-name (modus-themes-get-current-theme)))
      (setq win/theme "0")
      (setq win/theme "1"))
  (async-shell-command
     (concat
      "powershell New-ItemProperty -Path HKCU:/SOFTWARE/Microsoft/Windows/CurrentVersion/Themes/Personalize -Name AppsUseLightTheme -Value "
      win/theme
      " -Type Dword -Force")
     "win/theme-toggle"
     ))


(add-hook 'modus-themes-after-load-theme-hook 'win/theme-align-with-emacs)
#+end_src

** auto hide taskbar

#+begin_src emacs-lisp
(defun win/taskbar-auto-hide ()
  (interactive)
  (async-shell-command
     "powershell -command
\"&{$p='HKCU:SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StuckRects3';
$v=(Get-ItemProperty -Path $p).Settings;
$v[8]=3;
&Set-ItemProperty -Path $p -Name Settings -Value $v;&Stop-Process -f -ProcessName explorer}\""
     "win/taskbar-auto-hide"))
#+end_src
** browse in edge
Some things only work in edge on my work computer
#+begin_src emacs-lisp
(defun win/browse-url-edge (url)
    (shell-command (concat "start msedge " url)))
#+end_src

** org clip image
Before I made changes to [[org-download]] this weas my janky solution, still here in
case it's needed

#+begin_src emacs-lisp
(defun win/org-clip-image ()
  "Take a screenshot into a time stamped unique-named file in the
same directory as the org-buffer and insert a link to this file."
  (interactive)
  (setq temp-image-filename
	  (make-temp-file
	   (concat
	    (file-relative-name buffer-file-name)
	    (format-time-string "_%Y%m%d_%H%M%S_"))
	   nil
	   ".png"))

  (shell-command (concat
		  "powershell -command \"Add-Type -AssemblyName System.Windows.Forms;"
		  "if ($([System.Windows.Forms.Clipboard]::ContainsImage())) {$image = [System.Windows.Forms.Clipboard]::GetImage();[System.Drawing.Bitmap]$image.Save('"
		  temp-image-filename
		  "',[System.Drawing.Imaging.ImageFormat]::Png); Write-Output 'clipboard content saved as file'} else {Write-Output 'clipboard does not contain image data'}\""))
  (org-attach-attach
   temp-image-filename
   nil
   `mv)
  (insert (concat
	   "[[file:"
	   (org-attach-dir)
	   "/"
	   (file-name-nondirectory temp-image-filename)
	   "]]"))
    (org-display-inline-images))
#+end_src
** hide dos eol
Some the files I work with don't have consistent line endings DOS or UNIX

#+begin_src emacs-lisp
(defun win/hide-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))
#+end_src


** exec ~.bat~ in new cmd window
Often emacs and windows don't always play nice together and causes emacs to lock
up, this executes a ~.bat~ script in a new window, which seems to fix the problems
I have.

This version keeps it as a sub process, if you need to fix that you can save the
~start-process~ to a variable and ~(set-process-query-on-exit-flag
start-process-variable nil)~
#+begin_src emacs-lisp
(defun win/cmd-exec-bat-new-window (input-str)
  (let ((cmd-str (concat "start cmd /k " input-str)))
    (start-process "cmd" nil "cmd.exe" "/C" cmd-str)))

#+end_src
** org-attatch dir in windows explorer
#+begin_src emacs-lisp
(defun org-attatch-open-win-explorer ()
  (interactive)
  (w32-shell-execute 1 (org-attach-dir-get-create)))
#+end_src
** dired open in windows default
#+begin_src emacs-lisp
(defun ads/dired-win-default ()
    (interactive)
    (let ((filename
	   (dired-replace-in-string "/" "\\" (dired-get-filename))))
      (w32-shell-execute 1 filename)))

(general-define-key
 :keymaps 'dired-mode-map
 "<tab>" 'ads/dired-win-default)
#+end_src
** overwrite git-lazy function
#+begin_src emacs-lisp
(add-to-list 'display-buffer-alist
  (cons "ads/git-lazy" (cons #'display-buffer-no-window nil)))
(defun ads/git-lazy ()
  (interactive)
  (save-buffer)
  (shell-command (concat "git stage " buffer-file-name) )
  (magit-diff-staged)
  (delete-other-windows)
  (shell-command (concat "git commit -m \"" (read-string "Commit Message:\t") "\""))
  (async-shell-command "git push" "ads/git-lazy")
  (magit-mode-bury-buffer))
#+end_src
** projectile caching
By default on windows projectile is set to index with ~native~ which ends up
ignoreing a projects ~.gitignore~
#+begin_src emacs-lisp
(setq projectile-indexing-method 'hybrid)
#+end_src

** projectil shell-global
#+begin_src emacs-lisp
(defun ads/projectile-shell-global ()
  (interactive)
  (projectile-switch-project-by-name  (concat git-directory "shell-global")))

(ads/leader-keys "cg" 'ads/projectile-shell-global)
#+end_src
** provide ~ms-windows.el~

#+begin_src emacs-lisp
(provide 'ms-windows.el)
#+end_src



* Linux
:PROPERTIES:
:header-args: emacs-lisp :tangle linux.el :results none :noweb yes :comments link
:END:
** nixconfig
jump to my nix config files
#+begin_src emacs-lisp
(ads/leader-keys
  "cn" '((lambda () (interactive)
           (projectile-switch-project-by-name "~/nix"))
	 :which-key "nix config"))

(ads/leader-keys
  "ch" '((lambda () (interactive)
           (projectile-switch-project-by-name "~/home-manager"))
	 :which-key "home-manager"))
#+end_src




* Mac
:PROPERTIES:
:header-args: emacs-lisp :tangle mac.el :results none :noweb yes :comments link
:END:
 OSX
#+begin_src emacs-lisp
(setq mac-command-modifier 'control
      mac-option-modifier 'meta
      mac-control-modifier 'meta
      mac-pass-command-to-system nil)
#+end_src



** Toggle themes

#+begin_src emacs-lisp
(defun mac/dark-mode-emacs-align ()
  "Align OSX theme with emacs light or dark mode"
  (if (string-search "vivendi"
		     (symbol-name (modus-themes-get-current-theme)))
      (setq mac/dark-mode "true")
      (setq mac/dark-mode "false"))
  (shell-command
   (concat
    "osascript -e 'tell app \"System Events\" to tell appearance preferences to set dark mode to "
    mac/dark-mode
    "'")))

(add-hook 'modus-themes-after-load-theme-hook 'mac/dark-mode-emacs-align)
#+end_src

** nixconfig
jump to my nix config files
#+begin_src emacs-lisp
(ads/leader-keys
  "cn" '((lambda () (interactive)
           (projectile-switch-project-by-name "~/nix"))
	 :which-key "nix config"))

(ads/leader-keys
  "ch" '((lambda () (interactive)
           (projectile-switch-project-by-name "~/home-manager"))
	 :which-key "home-manager"))
#+end_src





** Menu bar

Turn off the menu bar because I've never used it
#+begin_src emacs-lisp
(menu-bar-mode -1)
#+end_src

** Load work config
I only have a mac for work and the loading based on system name seems to not
work 100% of the time when called from startup.

#+begin_src emacs-lisp
(load-file (concat git-directory "konfig/work.el"))
#+end_src

** Dwim commands

#+begin_src emacs-lisp
(ads/leader-keys
  "tm" 'dwim-shell-commands-macos-toggle-menu-bar-autohide
  "tC" 'dwim-shell-commands-macos-caffeinate)
#+end_src
